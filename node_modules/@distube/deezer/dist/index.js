"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DeezerPlugin: () => DeezerPlugin,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/API.ts
var import_undici = require("undici");
var api = new import_undici.Pool("https://api.deezer.com");
var get = /* @__PURE__ */ __name(async (path) => {
  const { body } = await api.request({
    path,
    method: "GET"
  });
  const data = await body.json();
  if (data.error)
    throw new Error(data.error?.message);
  return data;
}, "get");
var getTrack = /* @__PURE__ */ __name(async (id) => get(`/track/${id}`), "getTrack");
var getAlbum = /* @__PURE__ */ __name(async (id) => get(`/album/${id}`), "getAlbum");
var getPlaylist = /* @__PURE__ */ __name(async (id) => get(`/playlist/${id}`), "getPlaylist");

// src/index.ts
var import_distube = require("distube");
var SUPPORTED_TYPES = ["album", "playlist", "track"];
var REGEX = /^https?:\/\/(?:www\.)?deezer\.com\/(?:[a-z]{2}\/)?(track|album|playlist)\/(\d+)\/?(?:\?.*?)?$/;
var isTruthy = /* @__PURE__ */ __name((x) => Boolean(x), "isTruthy");
var DeezerPlugin = class extends import_distube.CustomPlugin {
  constructor(options = {}) {
    super();
    __publicField(this, "parallel");
    __publicField(this, "emitEventsAfterFetching");
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new import_distube.DisTubeError("INVALID_TYPE", ["object", "undefined"], options, "DeezerPluginOptions");
    }
    (0, import_distube.checkInvalidKey)(options, ["parallel", "emitEventsAfterFetching", "api"], "DeezerPluginOptions");
    this.parallel = options.parallel ?? true;
    if (typeof this.parallel !== "boolean") {
      throw new import_distube.DisTubeError("INVALID_TYPE", "boolean", this.parallel, "DeezerPluginOptions.parallel");
    }
    this.emitEventsAfterFetching = options.emitEventsAfterFetching ?? false;
    if (typeof this.emitEventsAfterFetching !== "boolean") {
      throw new import_distube.DisTubeError(
        "INVALID_TYPE",
        "boolean",
        this.emitEventsAfterFetching,
        "DeezerPluginOptions.emitEventsAfterFetching"
      );
    }
  }
  parseURL(url) {
    const [, type, id] = url.match(REGEX) ?? [];
    return { type, id };
  }
  async validate(url) {
    if (typeof url !== "string" || !url.includes("deezer"))
      return false;
    const { type, id } = this.parseURL(url);
    if (!type || !id || !SUPPORTED_TYPES.includes(type))
      return false;
    return true;
  }
  async play(voiceChannel, url, options) {
    const DT = this.distube;
    const { member, textChannel, skip, position, metadata } = Object.assign({ position: 0 }, options);
    const { type, id } = this.parseURL(url);
    if (!type || !id) {
      throw new import_distube.DisTubeError("DEEZER_PLUGIN_INVALID_URL", `Invalid Deezer url: ${url}`);
    }
    const api2 = type === "track" ? getTrack(id) : type === "album" ? getAlbum(id) : getPlaylist(id);
    const data = await api2.catch((e) => {
      throw new import_distube.DisTubeError("DEEZER_PLUGIN_API_ERROR", e.message);
    });
    if (!data.type || !SUPPORTED_TYPES.includes(data.type)) {
      throw new import_distube.DisTubeError("DEEZER_PLUGIN_NOT_SUPPORTED", "This deezer link is not supported.");
    }
    if (data.type === "track") {
      const query = `${data.title} ${data.contributors.map((a) => a.name).join(" ")}`;
      const result = await this.search(query);
      if (!result)
        throw new import_distube.DisTubeError("DEEZER_PLUGIN_NO_RESULT", `Cannot find "${query}" on YouTube.`);
      await DT.play(voiceChannel, result, options);
    } else {
      const name = data.title;
      const thumbnail = data.type == "album" ? data.cover_xl || data.cover_big || data.cover_medium || data.cover : data.picture_xl || data.picture_big || data.picture_medium || data.picture;
      const queries = data.tracks.data.map((t) => `${t.title} ${t.artist.name}`);
      const url2 = data.link;
      let firstSong;
      const getFirstSong = /* @__PURE__ */ __name(async () => {
        const firstQuery = queries.shift();
        if (!firstQuery)
          return;
        const result = await this.search(firstQuery);
        if (!result)
          return;
        firstSong = new import_distube.Song(result, { member, metadata });
      }, "getFirstSong");
      while (!firstSong) {
        await getFirstSong();
      }
      if (!firstSong) {
        throw new import_distube.DisTubeError("DEEZER_PLUGIN_NO_RESULT", `Cannot find any tracks of "${name}" on YouTube.`);
      }
      const queue = DT.getQueue(voiceChannel);
      const playlistInfo = {
        source: "deezer",
        songs: [firstSong],
        name,
        thumbnail,
        member,
        url: url2
      };
      const playlist = new import_distube.Playlist(playlistInfo, { member, metadata });
      const fetchTheRest = /* @__PURE__ */ __name(async (q, fs) => {
        if (queries.length) {
          let results = [];
          if (this.parallel) {
            results = await Promise.all(queries.map((query) => this.search(query)));
          } else {
            for (let i = 0; i < queries.length; i++) {
              results[i] = await this.search(queries[i]);
            }
          }
          playlist.songs = results.filter(isTruthy).map((r) => {
            const s = new import_distube.Song(r, { member, metadata });
            s.playlist = playlist;
            return s;
          });
          q.addToQueue(playlist.songs, !skip && position > 0 ? position + 1 : position);
        }
        playlist.songs.unshift(fs);
      }, "fetchTheRest");
      if (queue) {
        queue.addToQueue(firstSong, position);
        if (skip)
          queue.skip();
        else if (!this.emitEventsAfterFetching)
          DT.emit("addList", queue, playlist);
        await fetchTheRest(queue, firstSong);
        if (!skip && this.emitEventsAfterFetching)
          DT.emit("addList", queue, playlist);
      } else {
        let newQueue = await DT.queues.create(voiceChannel, firstSong, textChannel);
        while (newQueue === true) {
          await getFirstSong();
          newQueue = await DT.queues.create(voiceChannel, firstSong, textChannel);
        }
        if (!this.emitEventsAfterFetching) {
          if (DT.options.emitAddListWhenCreatingQueue)
            DT.emit("addList", newQueue, playlist);
          DT.emit("playSong", newQueue, firstSong);
        }
        await fetchTheRest(newQueue, firstSong);
        if (this.emitEventsAfterFetching) {
          if (DT.options.emitAddListWhenCreatingQueue)
            DT.emit("addList", newQueue, playlist);
          DT.emit("playSong", newQueue, firstSong);
        }
      }
    }
  }
  async search(query) {
    try {
      return (await this.distube.search(query, { limit: 1 }))[0];
    } catch {
      return null;
    }
  }
};
__name(DeezerPlugin, "DeezerPlugin");
var src_default = DeezerPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DeezerPlugin
});
//# sourceMappingURL=index.js.map