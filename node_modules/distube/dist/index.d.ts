import * as ytdl from '@distube/ytdl-core';
import ytdl__default, { Cookie } from '@distube/ytdl-core';
import * as discord_js from 'discord.js';
import { GuildTextBasedChannel, Message, Snowflake, VoiceBasedChannel, VoiceState, Guild, GuildMember, Interaction, Client, Collection, ClientOptions } from 'discord.js';
import ytpl from '@distube/ytpl';
import { Video, Playlist as Playlist$1 } from '@distube/ytsr';
import { TypedEmitter } from 'tiny-typed-emitter';
import { AudioPlayer, VoiceConnection, AudioResource, StreamType as StreamType$1 } from '@discordjs/voice';
import { FFmpeg } from 'prism-media';
import * as _discordjs_collection from '@discordjs/collection';

type Awaitable<T = any> = T | PromiseLike<T>;
type DisTubeVoiceEvents = {
    disconnect: (error?: Error) => Awaitable;
    error: (error: Error) => Awaitable;
    finish: () => Awaitable;
};
type DisTubeEvents = {
    error: [channel: GuildTextBasedChannel | undefined, error: Error];
    addList: [queue: Queue, playlist: Playlist];
    addSong: [queue: Queue, song: Song];
    playSong: [queue: Queue, song: Song];
    finishSong: [queue: Queue, song: Song];
    empty: [queue: Queue];
    finish: [queue: Queue];
    initQueue: [queue: Queue];
    noRelated: [queue: Queue];
    disconnect: [queue: Queue];
    deleteQueue: [queue: Queue];
    searchCancel: [message: Message<true>, query: string];
    searchNoResult: [message: Message<true>, query: string];
    searchDone: [message: Message<true>, answer: Message<true>, query: string];
    searchInvalidAnswer: [message: Message<true>, answer: Message<true>, query: string];
    searchResult: [message: Message<true>, results: SearchResult[], query: string];
};
type TypedDisTubeEvents = {
    [K in keyof DisTubeEvents]: (...args: DisTubeEvents[K]) => Awaitable;
};
/**
 * An FFmpeg audio filter object
 * ```
 * {
 *   name:  "bassboost",
 *   value: "bass=g=10"
 * }
 * ```
 * @typedef {Object} Filter
 * @prop {string} name Name of the filter
 * @prop {string} value FFmpeg audio filter(s)
 */
interface Filter {
    name: string;
    value: string;
}
/**
 * Data that resolves to give an FFmpeg audio filter. This can be:
 * - A name of a default filters or custom filters (`string`)
 * - A {@link Filter} object
 * @typedef {string|Filter} FilterResolvable
 * @see {@link defaultFilters}
 * @see {@link DisTubeOptions|DisTubeOptions.customFilters}
 */
type FilterResolvable = string | Filter;
/**
 * FFmpeg Filters
 * ```
 * {
 *   "Filter Name": "Filter Value",
 *   "bassboost":   "bass=g=10"
 * }
 * ```
 * @typedef {Object.<string, string>} Filters
 * @see {@link defaultFilters}
 */
type Filters = Record<string, string>;
/**
 * DisTube options.
 * @typedef {Object} DisTubeOptions
 * @prop {Array<CustomPlugin|ExtractorPlugin>} [plugins] DisTube plugins.
 * @prop {boolean} [emitNewSongOnly=false] Whether or not emitting {@link DisTube#event:playSong} event
 * when looping a song or next song is the same as the previous one
 * @prop {boolean} [leaveOnEmpty=true] Whether or not leaving voice channel
 * if the voice channel is empty after {@link DisTubeOptions}.emptyCooldown seconds.
 * @prop {boolean} [leaveOnFinish=false] Whether or not leaving voice channel when the queue ends.
 * @prop {boolean} [leaveOnStop=true] Whether or not leaving voice channel after using {@link DisTube#stop} function.
 * @prop {boolean} [savePreviousSongs=true] Whether or not saving the previous songs of the queue
 * and enable {@link DisTube#previous} method
 * @prop {number} [searchSongs=0] Limit of search results emits in {@link DisTube#event:searchResult} event
 * when {@link DisTube#play} method executed. If `searchSongs <= 1`, play the first result
 * @prop {Cookie[]|string} [youtubeCookie] YouTube cookies. Guide: {@link https://distube.js.org/#/docs/DisTube/main/general/cookie YouTube Cookies}
 * @prop {Filters} [customFilters] Override {@link defaultFilters} or add more ffmpeg filters.
 * @prop {ytdl.getInfoOptions} [ytdlOptions] `ytdl-core` get info options
 * @prop {number} [searchCooldown=60] Built-in search cooldown in seconds (When searchSongs is bigger than 0)
 * @prop {number} [emptyCooldown=60] Built-in leave on empty cooldown in seconds (When leaveOnEmpty is true)
 * @prop {boolean} [nsfw=false] Whether or not playing age-restricted content
 * and disabling safe search in non-NSFW channel.
 * @prop {boolean} [emitAddListWhenCreatingQueue=true] Whether or not emitting `addList` event when creating a new Queue
 * @prop {boolean} [emitAddSongWhenCreatingQueue=true] Whether or not emitting `addSong` event when creating a new Queue
 * @prop {boolean} [joinNewVoiceChannel=true] Whether or not joining the new voice channel
 * when using {@link DisTube#play} method
 * @prop {StreamType} [streamType=StreamType.OPUS] Decide the {@link DisTubeStream#type} will be used
 * (Not the same as {@link DisTubeStream#type})
 * @prop {boolean} [directLink=true] Whether or not playing a song with direct link
 */
type DisTubeOptions = {
    plugins?: (CustomPlugin | ExtractorPlugin)[];
    emitNewSongOnly?: boolean;
    leaveOnFinish?: boolean;
    leaveOnStop?: boolean;
    leaveOnEmpty?: boolean;
    emptyCooldown?: number;
    savePreviousSongs?: boolean;
    searchSongs?: number;
    searchCooldown?: number;
    youtubeCookie?: Cookie[] | string;
    customFilters?: Filters;
    ytdlOptions?: ytdl__default.downloadOptions;
    nsfw?: boolean;
    emitAddSongWhenCreatingQueue?: boolean;
    emitAddListWhenCreatingQueue?: boolean;
    joinNewVoiceChannel?: boolean;
    streamType?: StreamType;
    directLink?: boolean;
};
/**
 * Data that can be resolved to give a guild id string. This can be:
 * - A guild id string | a guild {@link https://discord.js.org/#/docs/main/stable/class/Snowflake|Snowflake}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/Guild|Guild}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/Message|Message}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/BaseGuildVoiceChannel|BaseGuildVoiceChannel}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/BaseGuildTextChannel|BaseGuildTextChannel}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/VoiceState|VoiceState}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/GuildMember|GuildMember}
 * - A {@link https://discord.js.org/#/docs/main/stable/class/Interaction|Interaction}
 * - A {@link DisTubeVoice}
 * - A {@link Queue}
 * @typedef {
 * Discord.Snowflake|
 * Discord.Guild|
 * Discord.Message|
 * Discord.BaseGuildVoiceChannel|
 * Discord.BaseGuildTextChannel|
 * Discord.VoiceState|
 * Discord.GuildMember|
 * Discord.Interaction|
 * DisTubeVoice|
 * Queue|
 * string
 * } GuildIdResolvable
 */
type GuildIdResolvable = Queue | DisTubeVoice | Snowflake | Message | GuildTextBasedChannel | VoiceBasedChannel | VoiceState | Guild | GuildMember | Interaction | string;
interface OtherSongInfo {
    src: string;
    id?: string;
    title?: string;
    name?: string;
    is_live?: boolean;
    isLive?: boolean;
    _duration_raw?: string | number;
    duration?: string | number;
    webpage_url?: string;
    url: string;
    thumbnail?: string;
    related?: RelatedSong[];
    view_count?: string | number;
    views?: string | number;
    like_count?: string | number;
    likes?: string | number;
    dislike_count?: string | number;
    dislikes?: string | number;
    repost_count?: string | number;
    reposts?: string | number;
    uploader?: string | {
        name: string;
        url: string;
    };
    uploader_url?: string;
    age_limit?: string | number;
    chapters?: Chapter[];
    age_restricted?: boolean;
}
interface Chapter {
    title: string;
    start_time: number;
}
interface PlaylistInfo {
    source: string;
    member?: GuildMember;
    songs: Song[];
    name?: string;
    url?: string;
    thumbnail?: string;
    /** @deprecated */
    title?: string;
    /** @deprecated */
    webpage_url?: string;
}
type RelatedSong = Omit<Song, "related">;
/**
 * @typedef {Object} PlayHandlerOptions
 * @prop {Discord.BaseGuildTextChannel} [options.textChannel] The default text channel of the queue
 * @prop {boolean} [options.skip=false] Skip the playing song (if exists) and play the added playlist instantly
 * @prop {number} [options.position=0] Position of the song/playlist to add to the queue,
 * <= 0 to add to the end of the queue.
 */
type PlayHandlerOptions = {
    skip?: boolean;
    position?: number;
    textChannel?: GuildTextBasedChannel;
};
/**
 * @typedef {Object} PlayOptions
 * @prop {Discord.GuildMember} [member] Requested user (default is your bot)
 * @prop {Discord.BaseGuildTextChannel} [textChannel] Default {@link Queue#textChannel}
 * @prop {boolean} [skip=false]
 * Skip the playing song (if exists) and play the added song/playlist if `position` is 1.
 * If `position` is defined and not equal to 1, it will skip to the next song instead of the added song
 * @prop {number} [position=0] Position of the song/playlist to add to the queue,
 * <= 0 to add to the end of the queue.
 * @prop {Discord.Message} [message] Called message (For built-in search events. If this is a {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy|falsy value}, it will play the first result instead)
 * @prop {*} [metadata] Optional metadata that can be attached to the song/playlist will be played,
 * This is useful for identification purposes when the song/playlist is passed around in events.
 * See {@link Song#metadata} or {@link Playlist#metadata}
 */
interface PlayOptions extends PlayHandlerOptions, ResolveOptions<any> {
    message?: Message;
}
/**
 * @typedef {Object} ResolveOptions
 * @prop {Discord.GuildMember} [member] Requested user
 * @prop {*} [metadata] Metadata
 */
interface ResolveOptions<T = unknown> {
    member?: GuildMember;
    metadata?: T;
}
/**
 * @typedef {ResolveOptions} ResolvePlaylistOptions
 * @prop {string} [source] Source of the playlist
 */
interface ResolvePlaylistOptions<T = unknown> extends ResolveOptions<T> {
    source?: string;
}
/**
 * @typedef {Object} CustomPlaylistOptions
 * @prop {Discord.GuildMember} [member] A guild member creating the playlist
 * @prop {Object} [properties] Additional properties such as `name`
 * @prop {boolean} [parallel=true] Whether or not fetch the songs in parallel
 * @prop {*} [metadata] Metadata
 */
interface CustomPlaylistOptions {
    member?: GuildMember;
    properties?: Record<string, any>;
    parallel?: boolean;
    metadata?: any;
}
/**
 * The repeat mode of a {@link Queue}
 * * `DISABLED` = 0
 * * `SONG` = 1
 * * `QUEUE` = 2
 * @typedef {number} RepeatMode
 */
declare enum RepeatMode {
    DISABLED = 0,
    SONG = 1,
    QUEUE = 2
}
/**
 * All available plugin types:
 * * `CUSTOM` = `"custom"`: {@link CustomPlugin}
 * * `EXTRACTOR` = `"extractor"`: {@link ExtractorPlugin}
 * @typedef {"custom"|"extractor"} PluginType
 */
declare enum PluginType {
    CUSTOM = "custom",
    EXTRACTOR = "extractor"
}
/**
 * Search result types:
 * * `VIDEO` = `"video"`
 * * `PLAYLIST` = `"playlist"`
 * @typedef {"video"|"playlist"} SearchResultType
 */
declare enum SearchResultType {
    VIDEO = "video",
    PLAYLIST = "playlist"
}
/**
 * Stream types:
 * * `OPUS` = `0` (Better quality, use more resources - **Recommended**)
 * * `RAW` = `1` (Better performance, use less resources)
 * @typedef {number} StreamType
 * @type {StreamType}
 */
declare enum StreamType {
    OPUS = 0,
    RAW = 1
}
/**
 * @typedef {Object} Events
 * @prop {string} ERROR error
 * @prop {string} ADD_LIST addList
 * @prop {string} ADD_SONG addSong
 * @prop {string} PLAY_SONG playSong
 * @prop {string} FINISH_SONG finishSong
 * @prop {string} EMPTY empty
 * @prop {string} FINISH finish
 * @prop {string} INIT_QUEUE initQueue
 * @prop {string} NO_RELATED noRelated
 * @prop {string} DISCONNECT disconnect
 * @prop {string} DELETE_QUEUE deleteQueue
 * @prop {string} SEARCH_CANCEL searchCancel
 * @prop {string} SEARCH_NO_RESULT searchNoResult
 * @prop {string} SEARCH_DONE searchDone
 * @prop {string} SEARCH_INVALID_ANSWER searchInvalidAnswer
 * @prop {string} SEARCH_RESULT searchResult
 */
declare enum Events {
    ERROR = "error",
    ADD_LIST = "addList",
    ADD_SONG = "addSong",
    PLAY_SONG = "playSong",
    FINISH_SONG = "finishSong",
    EMPTY = "empty",
    FINISH = "finish",
    INIT_QUEUE = "initQueue",
    NO_RELATED = "noRelated",
    DISCONNECT = "disconnect",
    DELETE_QUEUE = "deleteQueue",
    SEARCH_CANCEL = "searchCancel",
    SEARCH_NO_RESULT = "searchNoResult",
    SEARCH_DONE = "searchDone",
    SEARCH_INVALID_ANSWER = "searchInvalidAnswer",
    SEARCH_RESULT = "searchResult"
}

/**
 * Default DisTube audio filters.
 * @typedef {Object} defaultFilters
 * @prop {string} 3d 3d
 * @prop {string} bassboost bassboost
 * @prop {string} echo echo
 * @prop {string} karaoke karaoke
 * @prop {string} nightcore nightcore
 * @prop {string} vaporwave vaporwave
 * @prop {string} flanger flanger
 * @prop {string} gate gate
 * @prop {string} haas haas
 * @prop {string} reverse reverse
 * @prop {string} surround surround
 * @prop {string} mcompand mcompand
 * @prop {string} phaser phaser
 * @prop {string} tremolo tremolo
 * @prop {string} earwax earwax
 */
declare const defaultFilters: Filters;
declare const defaultOptions: {
    plugins: never[];
    emitNewSongOnly: boolean;
    leaveOnEmpty: boolean;
    leaveOnFinish: boolean;
    leaveOnStop: boolean;
    savePreviousSongs: boolean;
    searchSongs: number;
    ytdlOptions: {};
    searchCooldown: number;
    emptyCooldown: number;
    nsfw: boolean;
    emitAddSongWhenCreatingQueue: boolean;
    emitAddListWhenCreatingQueue: boolean;
    joinNewVoiceChannel: boolean;
    streamType: StreamType;
    directLink: boolean;
};

declare const ERROR_MESSAGES: {
    INVALID_TYPE: (expected: (number | string) | readonly (number | string)[], got: any, name?: string) => string;
    NUMBER_COMPARE: (name: string, expected: string, value: number) => string;
    EMPTY_ARRAY: (name: string) => string;
    EMPTY_FILTERED_ARRAY: (name: string, type: string) => string;
    EMPTY_STRING: (name: string) => string;
    INVALID_KEY: (obj: string, key: string) => string;
    MISSING_KEY: (obj: string, key: string) => string;
    MISSING_KEYS: (obj: string, key: string[], all: boolean) => string;
    MISSING_INTENTS: (i: string) => string;
    DISABLED_OPTION: (o: string) => string;
    ENABLED_OPTION: (o: string) => string;
    NOT_IN_VOICE: string;
    VOICE_FULL: string;
    VOICE_CONNECT_FAILED: (s: number) => string;
    VOICE_MISSING_PERMS: string;
    VOICE_RECONNECT_FAILED: string;
    VOICE_DIFFERENT_GUILD: string;
    VOICE_DIFFERENT_CLIENT: string;
    NO_QUEUE: string;
    QUEUE_EXIST: string;
    PAUSED: string;
    RESUMED: string;
    NO_PREVIOUS: string;
    NO_UP_NEXT: string;
    NO_SONG_POSITION: string;
    NO_PLAYING: string;
    NO_RESULT: string;
    NO_RELATED: string;
    CANNOT_PLAY_RELATED: string;
    UNAVAILABLE_VIDEO: string;
    UNPLAYABLE_FORMATS: string;
    NON_NSFW: string;
    NOT_SUPPORTED_URL: string;
    CANNOT_RESOLVE_SONG: (t: any) => string;
    NO_VALID_SONG: string;
    EMPTY_FILTERED_PLAYLIST: string;
    EMPTY_PLAYLIST: string;
};
type ErrorMessage = typeof ERROR_MESSAGES;
type ErrorCode = keyof ErrorMessage;
type StaticErrorCode = {
    [K in ErrorCode]-?: ErrorMessage[K] extends string ? K : never;
}[ErrorCode];
type TemplateErrorCode = Exclude<keyof typeof ERROR_MESSAGES, StaticErrorCode>;
declare class DisTubeError<T extends string> extends Error {
    errorCode: string;
    constructor(code: StaticErrorCode);
    constructor(code: T extends TemplateErrorCode ? T : never, ...args: Parameters<ErrorMessage[typeof code]>);
    constructor(code: TemplateErrorCode, _: never);
    constructor(code: T extends ErrorCode ? "This is built-in error code" : T, message: string);
    get name(): string;
    get code(): string;
}

/**
 * Task queuing system
 * @private
 */
declare class TaskQueue {
    #private;
    /**
     * Waits for last task finished and queues a new task
     * @param {boolean} [resolveInfo=false] Whether the task is a resolving info task
     * @returns {Promise<void>}
     */
    queuing(resolveInfo?: boolean): Promise<void>;
    /**
     * Removes the finished task and processes the next task
     */
    resolve(): void;
    /**
     * The remaining number of tasks
     * @type {number}
     */
    get remaining(): number;
    /**
     * Whether or not having a resolving info task
     * @type {boolean}
     */
    get hasResolveTask(): boolean;
}

/**
 * Class representing a playlist.
 * @prop {string} source Playlist source
 * @template T - The type for the metadata (if any) of the playlist
 */
declare class Playlist<T = unknown> implements PlaylistInfo {
    #private;
    source: string;
    songs: Song[];
    name: string;
    url?: string;
    thumbnail?: string;
    [x: string]: any;
    /**
     * Create a playlist
     * @param {Song[]|PlaylistInfo} playlist Playlist
     * @param {Object} [options] Optional options
     * @param {Discord.GuildMember} [options.member] Requested user
     * @param {Object} [options.properties] Custom properties
     * @param {T} [options.metadata] Playlist metadata
     */
    constructor(playlist: Song[] | PlaylistInfo, options?: {
        member?: GuildMember;
        properties?: Record<string, any>;
        metadata?: T;
    });
    /**
     * Playlist duration in second.
     * @type {number}
     */
    get duration(): number;
    /**
     * Formatted duration string `hh:mm:ss`.
     * @type {string}
     */
    get formattedDuration(): string;
    /**
     * User requested.
     * @type {Discord.GuildMember?}
     */
    get member(): GuildMember | undefined;
    set member(member: GuildMember | undefined);
    /**
     * User requested.
     * @type {Discord.User?}
     */
    get user(): discord_js.User | undefined;
    get metadata(): T;
    set metadata(metadata: T);
}

/**
 * A abstract class representing a search result.
 * @abstract
 * @private
 */
declare abstract class ISearchResult {
    source: "youtube";
    abstract type: SearchResultType;
    id: string;
    name: string;
    url: string;
    uploader: {
        name?: string;
        url?: string;
    };
    /**
     * Create a search result
     * @param {Object} info ytsr result
     */
    constructor(info: Video | Playlist$1);
}
/**
 * A class representing a video search result.
 * @extends ISearchResult
 */
declare class SearchResultVideo extends ISearchResult {
    type: SearchResultType.VIDEO;
    views: number;
    isLive: boolean;
    duration: number;
    formattedDuration: string;
    thumbnail: string;
    constructor(info: Video);
}
/**
 * A video or playlist search result
 * @typedef {SearchResultVideo|SearchResultPlaylist} SearchResult
 */
type SearchResult = SearchResultVideo | SearchResultPlaylist;
/**
 * A class representing a playlist search result.
 * @extends ISearchResult
 */
declare class SearchResultPlaylist extends ISearchResult {
    type: SearchResultType.PLAYLIST;
    length: number;
    constructor(info: Playlist$1);
}

/**
 * Class representing a song.
 *
 * <info>If {@link Song} is added from a YouTube {@link SearchResult} or {@link Playlist},
 * some info will be missing to save your resources. It will be filled when emitting {@link DisTube#playSong} event.
 *
 * Missing info: {@link Song#likes}, {@link Song#dislikes}, {@link Song#streamURL},
 * {@link Song#related}, {@link Song#chapters}, {@link Song#age_restricted}</info>
 * @template T - The type for the metadata (if any) of the song
 */
declare class Song<T = unknown> {
    #private;
    source: string;
    formats?: ytdl__default.videoFormat[];
    id?: string;
    name?: string;
    isLive: boolean;
    duration: number;
    formattedDuration?: string;
    url: string;
    streamURL?: string;
    thumbnail?: string;
    related: RelatedSong[];
    views: number;
    likes: number;
    dislikes: number;
    uploader: {
        name?: string;
        url?: string;
    };
    age_restricted: boolean;
    chapters: Chapter[];
    reposts: number;
    /**
     * Create a Song
     * @param {ytdl.videoInfo|SearchResult|OtherSongInfo} info Raw info
     * @param {Object} [options] Optional options
     * @param {Discord.GuildMember} [options.member] Requested user
     * @param {string} [options.source="youtube"] Song source
     * @param {T} [options.metadata] Song metadata
     */
    constructor(info: ytdl__default.videoInfo | SearchResult | OtherSongInfo | ytdl__default.relatedVideo | RelatedSong | ytpl.result["items"][number], options?: {
        member?: GuildMember;
        source?: string;
        metadata?: T;
    });
    _patchYouTube(i: ytdl__default.videoInfo | SearchResult): void;
    /**
     * Patch data from other source
     * @param {OtherSongInfo} info Video info
     * @private
     */
    _patchOther(info: OtherSongInfo): void;
    /**
     * The playlist added this song
     * @type {Playlist?}
     */
    get playlist(): Playlist | undefined;
    set playlist(playlist: Playlist | undefined);
    /**
     * User requested.
     * @type {Discord.GuildMember?}
     */
    get member(): GuildMember | undefined;
    set member(member: GuildMember | undefined);
    /**
     * User requested.
     * @type {Discord.User?}
     */
    get user(): discord_js.User | undefined;
    get metadata(): T;
    set metadata(metadata: T);
}

/**
 * @private
 * @abstract
 */
declare abstract class DisTubeBase {
    distube: DisTube;
    constructor(distube: DisTube);
    /**
     * Emit the {@link DisTube} of this base
     * @param {string} eventName Event name
     * @param {...any} args arguments
     * @returns {boolean}
     */
    emit(eventName: keyof DisTubeEvents, ...args: any): boolean;
    /**
     * Emit error event
     * @param {Error} error error
     * @param {Discord.BaseGuildTextChannel} [channel] Text channel where the error is encountered.
     */
    emitError(error: Error, channel?: GuildTextBasedChannel): void;
    /**
     * The queue manager
     * @type {QueueManager}
     * @readonly
     */
    get queues(): QueueManager;
    /**
     * The voice manager
     * @type {DisTubeVoiceManager}
     * @readonly
     */
    get voices(): DisTubeVoiceManager;
    /**
     * Discord.js client
     * @type {Discord.Client}
     * @readonly
     */
    get client(): Client;
    /**
     * DisTube options
     * @type {DisTubeOptions}
     * @readonly
     */
    get options(): Options;
    /**
     * DisTube handler
     * @type {DisTubeHandler}
     * @readonly
     */
    get handler(): DisTubeHandler;
}

/**
 * Create a voice connection to the voice channel
 */
declare class DisTubeVoice extends TypedEmitter<DisTubeVoiceEvents> {
    #private;
    readonly id: Snowflake;
    readonly voices: DisTubeVoiceManager;
    readonly audioPlayer: AudioPlayer;
    connection: VoiceConnection;
    audioResource?: AudioResource;
    emittedError: boolean;
    isDisconnected: boolean;
    constructor(voiceManager: DisTubeVoiceManager, channel: VoiceBasedChannel);
    /**
     * The voice channel id the bot is in
     * @type {Snowflake?}
     */
    get channelId(): string | undefined;
    get channel(): VoiceBasedChannel;
    set channel(channel: VoiceBasedChannel);
    /**
     * Join a voice channel with this connection
     * @param {Discord.BaseGuildVoiceChannel} [channel] A voice channel
     * @returns {Promise<DisTubeVoice>}
     */
    join(channel?: VoiceBasedChannel): Promise<DisTubeVoice>;
    /**
     * Leave the voice channel of this connection
     * @param {Error} [error] Optional, an error to emit with 'error' event.
     */
    leave(error?: Error): void;
    /**
     * Stop the playing stream
     * @param {boolean} [force=false] If true, will force the {@link DisTubeVoice#audioPlayer} to enter the Idle state
     * even if the {@link DisTubeVoice#audioResource} has silence padding frames.
     * @private
     */
    stop(force?: boolean): void;
    /**
     * Play a readable stream
     * @private
     * @param {DisTubeStream} stream Readable stream
     */
    play(stream: DisTubeStream): void;
    set volume(volume: number);
    get volume(): number;
    /**
     * Playback duration of the audio resource in seconds
     * @type {number}
     */
    get playbackDuration(): number;
    pause(): void;
    unpause(): void;
    /**
     * Whether the bot is self-deafened
     * @type {boolean}
     */
    get selfDeaf(): boolean;
    /**
     * Whether the bot is self-muted
     * @type {boolean}
     */
    get selfMute(): boolean;
    /**
     * Self-deafens/undeafens the bot.
     * @param {boolean} selfDeaf Whether or not the bot should be self-deafened
     * @returns {boolean} true if the voice state was successfully updated, otherwise false
     */
    setSelfDeaf(selfDeaf: boolean): boolean;
    /**
     * Self-mutes/unmutes the bot.
     * @param {boolean} selfMute Whether or not the bot should be self-muted
     * @returns {boolean} true if the voice state was successfully updated, otherwise false
     */
    setSelfMute(selfMute: boolean): boolean;
    /**
     * The voice state of this connection
     * @type {Discord.VoiceState?}
     */
    get voiceState(): VoiceState | undefined;
}

interface StreamOptions {
    seek?: number;
    ffmpegArgs?: string[];
    type?: StreamType;
}
declare const chooseBestVideoFormat: ({ duration, formats, isLive }: Song) => ytdl.videoFormat | undefined;
/**
 * Create a stream to play with {@link DisTubeVoice}
 * @private
 */
declare class DisTubeStream {
    /**
     * Create a stream from ytdl video formats
     * @param {Song} song A YouTube Song
     * @param {StreamOptions} options options
     * @returns {DisTubeStream}
     * @private
     */
    static YouTube(song: Song, options?: StreamOptions): DisTubeStream;
    /**
     * Create a stream from a stream url
     * @param {string} url stream url
     * @param {StreamOptions} options options
     * @returns {DisTubeStream}
     * @private
     */
    static DirectLink(url: string, options?: StreamOptions): DisTubeStream;
    type: StreamType$1;
    stream: FFmpeg;
    url: string;
    /**
     * Create a DisTubeStream to play with {@link DisTubeVoice}
     * @param {string} url Stream URL
     * @param {StreamOptions} options Stream options
     * @private
     */
    constructor(url: string, options: StreamOptions);
}

/**
 * DisTube's Handler
 * @extends DisTubeBase
 * @private
 */
declare class DisTubeHandler extends DisTubeBase {
    #private;
    constructor(distube: DisTube);
    get ytdlOptions(): ytdl__default.getInfoOptions;
    get ytCookie(): string;
    /**
     * @param {string} url url
     * @param {boolean} [basic=false] getBasicInfo?
     * @returns {Promise<ytdl.videoInfo>}
     */
    getYouTubeInfo(url: string, basic?: boolean): Promise<ytdl__default.videoInfo>;
    resolve<T = unknown>(song: Song<T>, options?: Omit<ResolveOptions, "metadata">): Promise<Song<T>>;
    resolve<T = unknown>(song: Playlist<T>, options?: Omit<ResolveOptions, "metadata">): Promise<Playlist<T>>;
    resolve<T = unknown>(song: string | SearchResult, options?: ResolveOptions<T>): Promise<Song<T> | Playlist<T>>;
    resolve<T = unknown>(song: ytdl__default.videoInfo | OtherSongInfo | ytdl__default.relatedVideo, options?: ResolveOptions<T>): Promise<Song<T>>;
    resolve<T = unknown>(song: Playlist, options: ResolveOptions<T>): Promise<Playlist<T>>;
    resolve(song: string | ytdl__default.videoInfo | Song | Playlist | SearchResult | OtherSongInfo | ytdl__default.relatedVideo, options?: ResolveOptions): Promise<Song | Playlist>;
    resolvePlaylist<T = unknown>(playlist: Playlist<T> | Song<T>[] | string, options?: Omit<ResolvePlaylistOptions, "metadata">): Promise<Playlist<T>>;
    resolvePlaylist<T = undefined>(playlist: Playlist | Song[] | string, options: ResolvePlaylistOptions<T>): Promise<Playlist<T>>;
    resolvePlaylist(playlist: Playlist | Song[] | string, options?: ResolvePlaylistOptions): Promise<Playlist>;
    /**
     * Search for a song, fire {@link DisTube#event:error} if not found.
     * @param {Discord.Message} message The original message from an user
     * @param {string} query The query string
     * @returns {Promise<SearchResult?>} Song info
     * @throws {DisTubeError}
     */
    searchSong(message: Message<true>, query: string): Promise<SearchResult | null>;
    /**
     * Create a message collector for selecting search results.
     *
     * Needed events: {@link DisTube#event:searchResult}, {@link DisTube#event:searchCancel},
     * {@link DisTube#event:searchInvalidAnswer}, {@link DisTube#event:searchDone}.
     * @param {Discord.Message} message The original message from an user
     * @param {Array<SearchResult|Song|Playlist>} results The search results
     * @param {string?} [query] The query string
     * @returns {Promise<SearchResult|Song|Playlist|null>} Selected result
     * @throws {DisTubeError}
     */
    createSearchMessageCollector<R extends SearchResult | Song | Playlist>(message: Message<true>, results: Array<R>, query?: string): Promise<R | null>;
    /**
     * Play or add a {@link Playlist} to the queue.
     * @param {Discord.BaseGuildVoiceChannel} voiceChannel A voice channel
     * @param {Playlist|string} playlist A YouTube playlist url | a Playlist
     * @param {PlayHandlerOptions} [options] Optional options
     * @returns {Promise<void>}
     * @throws {DisTubeError}
     */
    playPlaylist(voiceChannel: VoiceBasedChannel, playlist: Playlist, options?: PlayHandlerOptions): Promise<void>;
    /**
     * Play or add a {@link Song} to the queue.
     * @param {Discord.BaseGuildVoiceChannel} voiceChannel A voice channel
     * @param {Song} song A YouTube playlist url | a Playlist
     * @param {PlayHandlerOptions} [options] Optional options
     * @returns {Promise<void>}
     * @throws {DisTubeError}
     */
    playSong(voiceChannel: VoiceBasedChannel, song: Song, options?: PlayHandlerOptions): Promise<void>;
    /**
     * Get {@link Song}'s stream info and attach it to the song.
     * @param {Song} song A Song
     */
    attachStreamInfo(song: Song): Promise<void>;
}

declare class Options {
    #private;
    plugins: (CustomPlugin | ExtractorPlugin)[];
    emitNewSongOnly: boolean;
    leaveOnFinish: boolean;
    leaveOnStop: boolean;
    leaveOnEmpty: boolean;
    emptyCooldown: number;
    savePreviousSongs: boolean;
    searchSongs: number;
    searchCooldown: number;
    youtubeCookie?: Cookie[] | string;
    customFilters?: Filters;
    ytdlOptions: ytdl__default.getInfoOptions;
    nsfw: boolean;
    emitAddSongWhenCreatingQueue: boolean;
    emitAddListWhenCreatingQueue: boolean;
    joinNewVoiceChannel: boolean;
    streamType: StreamType;
    directLink: boolean;
    constructor(options: DisTubeOptions);
}

/**
 * Manages the collection of a data model.
 * @abstract
 * @private
 * @extends DisTubeBase
 */
declare abstract class BaseManager<V> extends DisTubeBase {
    /**
     * The collection of items for this manager.
     * @type {Collection}
     * @name BaseManager#collection
     */
    collection: Collection<string, V>;
    /**
     * The size of the collection.
     * @type {number}
     */
    get size(): number;
}

/**
 * Manages the collection of a data model paired with a guild id.
 * @abstract
 * @private
 * @extends BaseManager
 */
declare abstract class GuildIdManager<V> extends BaseManager<V> {
    add(idOrInstance: GuildIdResolvable, data: V): this | _discordjs_collection.Collection<string, V>;
    get(idOrInstance: GuildIdResolvable): V | undefined;
    remove(idOrInstance: GuildIdResolvable): boolean;
    has(idOrInstance: GuildIdResolvable): boolean;
}

/**
 * Manages voice connections for {@link DisTube}
 * @extends BaseManager
 */
declare class DisTubeVoiceManager extends GuildIdManager<DisTubeVoice> {
    /**
     * Get a {@link DisTubeVoice}.
     * @method get
     * @memberof DisTubeVoiceManager#
     * @param {GuildIdResolvable} guild The queue resolvable to resolve
     * @returns {DisTubeVoice?}
     */
    /**
     * Collection of {@link DisTubeVoice}.
     * @name DisTubeVoiceManager#collection
     * @type {Discord.Collection<string, DisTubeVoice>}
     */
    /**
     * Create a {@link DisTubeVoice}
     * @param {Discord.BaseGuildVoiceChannel} channel A voice channel to join
     * @returns {DisTubeVoice}
     * @private
     */
    create(channel: VoiceBasedChannel): DisTubeVoice;
    /**
     * Join a voice channel
     * @param {Discord.BaseGuildVoiceChannel} channel A voice channel to join
     * @returns {Promise<DisTubeVoice>}
     */
    join(channel: VoiceBasedChannel): Promise<DisTubeVoice>;
    /**
     * Leave the connected voice channel in a guild
     * @param {GuildIdResolvable} guild Queue Resolvable
     */
    leave(guild: GuildIdResolvable): void;
}

/**
 * Manage filters of a playing {@link Queue}
 * @extends {BaseManager}
 */
declare class FilterManager extends BaseManager<Filter> {
    #private;
    /**
     * Collection of {@link Filter}.
     * @name FilterManager#collection
     * @type {Discord.Collection<string, DisTubeVoice>}
     */
    queue: Queue;
    constructor(queue: Queue);
    /**
     * Enable a filter or multiple filters to the manager
     * @param {FilterResolvable|FilterResolvable[]} filterOrFilters The filter or filters to enable
     * @param {boolean} [override=false] Wether or not override the applied filter with new filter value
     * @returns {FilterManager}
     */
    add(filterOrFilters: FilterResolvable | FilterResolvable[], override?: boolean): this;
    /**
     * Clear enabled filters of the manager
     * @returns {FilterManager}
     */
    clear(): this;
    /**
     * Set the filters applied to the manager
     * @param {FilterResolvable[]} filters The filters to apply
     * @returns {FilterManager}
     */
    set(filters: FilterResolvable[]): this;
    /**
     * Disable a filter or multiple filters
     * @param {FilterResolvable|FilterResolvable[]} filterOrFilters The filter or filters to disable
     * @returns {FilterManager}
     */
    remove(filterOrFilters: FilterResolvable | FilterResolvable[]): this;
    /**
     * Check whether a filter enabled or not
     * @param {FilterResolvable} filter The filter to check
     * @returns {boolean}
     */
    has(filter: FilterResolvable): boolean;
    /**
     * Array of enabled filter names
     * @type {Array<string>}
     * @readonly
     */
    get names(): string[];
    /**
     * Array of enabled filters
     * @type {Array<Filter>}
     * @readonly
     */
    get values(): Filter[];
    get ffmpegArgs(): string[];
    toString(): string;
}

/**
 * Queue manager
 * @extends GuildIdManager
 */
declare class QueueManager extends GuildIdManager<Queue> {
    #private;
    /**
     * Collection of {@link Queue}.
     * @name QueueManager#collection
     * @type {Discord.Collection<string, Queue>}
     */
    /**
     * Create a {@link Queue}
     * @private
     * @param {Discord.BaseGuildVoiceChannel} channel A voice channel
     * @param {Song|Song[]} song First song
     * @param {Discord.BaseGuildTextChannel} textChannel Default text channel
     * @returns {Promise<Queue|true>} Returns `true` if encounter an error
     */
    create(channel: VoiceBasedChannel, song: Song[] | Song, textChannel?: GuildTextBasedChannel): Promise<Queue | true>;
    /**
     * Create a ytdl stream
     * @param {Queue} queue Queue
     * @returns {DisTubeStream}
     */
    createStream(queue: Queue): DisTubeStream;
    /**
     * Play a song on voice connection
     * @private
     * @param {Queue} queue The guild queue
     * @returns {Promise<boolean>} error?
     */
    playSong(queue: Queue): Promise<boolean>;
}

/**
 * Represents a queue.
 * @extends DisTubeBase
 */
declare class Queue extends DisTubeBase {
    #private;
    readonly id: Snowflake;
    voice: DisTubeVoice;
    songs: Song[];
    previousSongs: Song[];
    stopped: boolean;
    _next: boolean;
    _prev: boolean;
    playing: boolean;
    paused: boolean;
    repeatMode: RepeatMode;
    autoplay: boolean;
    beginTime: number;
    textChannel?: GuildTextBasedChannel;
    _emptyTimeout?: NodeJS.Timeout;
    _taskQueue: TaskQueue;
    _listeners?: DisTubeVoiceEvents;
    /**
     * Create a queue for the guild
     * @param {DisTube} distube DisTube
     * @param {DisTubeVoice} voice Voice connection
     * @param {Song|Song[]} song First song(s)
     * @param {Discord.BaseGuildTextChannel?} textChannel Default text channel
     */
    constructor(distube: DisTube, voice: DisTubeVoice, song: Song | Song[], textChannel?: GuildTextBasedChannel);
    /**
     * The client user as a `GuildMember` of this queue's guild
     * @type {Discord.GuildMember?}
     */
    get clientMember(): discord_js.GuildMember | undefined;
    /**
     * The filter manager of the queue
     * @type {FilterManager}
     * @readonly
     */
    get filters(): FilterManager;
    /**
     * Formatted duration string.
     * @type {string}
     * @readonly
     */
    get formattedDuration(): string;
    /**
     * Queue's duration.
     * @type {number}
     * @readonly
     */
    get duration(): number;
    /**
     * What time in the song is playing (in seconds).
     * @type {number}
     * @readonly
     */
    get currentTime(): number;
    /**
     * Formatted {@link Queue#currentTime} string.
     * @type {string}
     * @readonly
     */
    get formattedCurrentTime(): string;
    /**
     * The voice channel playing in.
     * @type {Discord.VoiceChannel|Discord.StageChannel|null}
     * @readonly
     */
    get voiceChannel(): discord_js.VoiceBasedChannel | null;
    get volume(): number;
    set volume(value: number);
    /**
     * @private
     * Add a Song or an array of Song to the queue
     * @param {Song|Song[]} song Song to add
     * @param {number} [position=0] Position to add, <= 0 to add to the end of the queue
     * @throws {Error}
     * @returns {Queue} The guild queue
     */
    addToQueue(song: Song | Song[], position?: number): Queue;
    /**
     * Pause the guild stream
     * @returns {Queue} The guild queue
     */
    pause(): Queue;
    /**
     * Resume the guild stream
     * @returns {Queue} The guild queue
     */
    resume(): Queue;
    /**
     * Set the guild stream's volume
     * @param {number} percent The percentage of volume you want to set
     * @returns {Queue} The guild queue
     */
    setVolume(percent: number): Queue;
    /**
     * Skip the playing song if there is a next song in the queue.
     * <info>If {@link Queue#autoplay} is `true` and there is no up next song,
     * DisTube will add and play a related song.</info>
     * @returns {Promise<Song>} The song will skip to
     * @throws {Error}
     */
    skip(): Promise<Song>;
    /**
     * Play the previous song if exists
     * @returns {Promise<Song>} The guild queue
     * @throws {Error}
     */
    previous(): Promise<Song>;
    /**
     * Shuffle the queue's songs
     * @returns {Promise<Queue>} The guild queue
     */
    shuffle(): Promise<Queue>;
    /**
     * Jump to the song position in the queue.
     * The next one is 1, 2,...
     * The previous one is -1, -2,...
     * @param {number} position The song position to play
     * @returns {Promise<Song>} The new Song will be played
     * @throws {Error} if `num` is invalid number
     */
    jump(position: number): Promise<Song>;
    /**
     * Set the repeat mode of the guild queue.\
     * Toggle mode `(Disabled -> Song -> Queue -> Disabled ->...)` if `mode` is `undefined`
     * @param {RepeatMode?} [mode] The repeat modes (toggle if `undefined`)
     * @returns {RepeatMode} The new repeat mode
     */
    setRepeatMode(mode?: RepeatMode): RepeatMode;
    /**
     * Set the playing time to another position
     * @param {number} time Time in seconds
     * @returns {Queue} The guild queue
     */
    seek(time: number): Queue;
    /**
     * Add a related song of the playing song to the queue
     * @returns {Promise<Song>} The added song
     * @throws {Error}
     */
    addRelatedSong(): Promise<Song>;
    /**
     * Stop the guild stream and delete the queue
     */
    stop(): Promise<void>;
    /**
     * Remove the queue from the manager
     * (This does not leave the voice channel even if {@link DisTubeOptions|DisTubeOptions.leaveOnStop} is enabled)
     * @private
     */
    remove(): void;
    /**
     * Toggle autoplay mode
     * @returns {boolean} Autoplay mode state
     */
    toggleAutoplay(): boolean;
}

/**
 * DisTube Plugin
 * @abstract
 * @private
 */
declare abstract class Plugin {
    abstract type: PluginType;
    distube: DisTube;
    init(distube: DisTube): void;
    /**
     * Type of the plugin
     * @name Plugin#type
     * @type {PluginType}
     */
    /**
     * Emit an event to the {@link DisTube} class
     * @param {string} eventName Event name
     * @param {...any} args arguments
     * @returns {boolean}
     */
    emit(eventName: keyof DisTubeEvents, ...args: any): boolean;
    /**
     * Emit error event to the {@link DisTube} class
     * @param {Error} error error
     * @param {Discord.BaseGuildTextChannel} [channel] Text channel where the error is encountered.
     */
    emitError(error: Error, channel?: GuildTextBasedChannel): void;
    /**
     * The queue manager
     * @type {QueueManager}
     * @readonly
     */
    get queues(): QueueManager;
    /**
     * The voice manager
     * @type {DisTubeVoiceManager}
     * @readonly
     */
    get voices(): DisTubeVoiceManager;
    /**
     * Discord.js client
     * @type {Discord.Client}
     * @readonly
     */
    get client(): Client;
    /**
     * DisTube options
     * @type {DisTubeOptions}
     * @readonly
     */
    get options(): Options;
    /**
     * DisTube handler
     * @type {DisTubeHandler}
     * @readonly
     */
    get handler(): DisTubeHandler;
    /**
     * Check if the string is working with this plugin
     * @param {string} _string Input string
     * @returns {boolean|Promise<boolean>}
     */
    validate(_string: string): Awaitable<boolean>;
    /**
     * Get the stream url from {@link Song#url}. Returns {@link Song#url} by default.
     * Not needed if the plugin plays song from YouTube.
     * @param {string} url Input url
     * @returns {string|Promise<string>}
     */
    getStreamURL(url: string): Awaitable<string>;
    /**
     * Get related songs from a supported url. {@link Song#member} should be `undefined`.
     * Not needed to add {@link Song#related} because it will be added with this function later.
     * @param {string} _url Input url
     * @returns {Song[]|Promise<Song[]>}
     */
    getRelatedSongs(_url: string): Awaitable<RelatedSong[]>;
}

/**
 * Custom Plugin
 * @extends Plugin
 * @abstract
 */
declare abstract class CustomPlugin extends Plugin {
    readonly type = PluginType.CUSTOM;
    abstract play(voiceChannel: VoiceBasedChannel, song: string, options: PlayOptions): Awaitable<void>;
}

/**
 * Extractor Plugin
 * @extends Plugin
 * @abstract
 */
declare abstract class ExtractorPlugin extends Plugin {
    readonly type = PluginType.EXTRACTOR;
    abstract resolve<T = unknown>(url: string, options: {
        member?: GuildMember;
        metadata?: T;
    }): Awaitable<Song<T> | Playlist<T>>;
}

/**
 * Format duration to string
 * @param {number} sec Duration in seconds
 * @returns {string}
 */
declare function formatDuration(sec: number): string;
/**
 * Convert formatted duration to seconds
 * @param {*} input Formatted duration string
 * @returns {number}
 */
declare function toSecond(input: any): number;
/**
 * Parse number from input
 * @param {*} input Any
 * @returns {number}
 */
declare function parseNumber(input: any): number;
declare const SUPPORTED_PROTOCOL: readonly ["https:", "http:", "file:"];
/**
 * Check if the string is an URL
 * @param {string} input input
 * @returns {boolean}
 */
declare function isURL(input: any): input is `${(typeof SUPPORTED_PROTOCOL)[number]}//${string}`;
/**
 * Check if the Client has enough intents to using DisTube
 * @param {ClientOptions} options options
 */
declare function checkIntents(options: ClientOptions): void;
/**
 * Check if the voice channel is empty
 * @param {Discord.VoiceState} voiceState voiceState
 * @returns {boolean}
 */
declare function isVoiceChannelEmpty(voiceState: VoiceState): boolean;
declare function isSnowflake(id: any): id is Snowflake;
declare function isMemberInstance(member: any): member is GuildMember;
declare function isTextChannelInstance(channel: any): channel is GuildTextBasedChannel;
declare function isMessageInstance(message: any): message is Message<true>;
declare function isSupportedVoiceChannel(channel: any): channel is VoiceBasedChannel;
declare function isGuildInstance(guild: any): guild is Guild;
declare function resolveGuildId(resolvable: GuildIdResolvable): Snowflake;
declare function isClientInstance(client: any): client is Client;
declare function checkInvalidKey(target: Record<string, any>, source: Record<string, any> | string[], sourceName: string): void;
declare function isObject(obj: any): obj is object;
declare function isRecord<T = unknown>(obj: any): obj is Record<string, T>;
type KeyOf<T> = T extends object ? (keyof T)[] : [];
declare function objectKeys<T>(obj: T): KeyOf<T>;
declare function isNsfwChannel(channel?: GuildTextBasedChannel): boolean;
type Falsy = undefined | null | false | 0 | "";
declare const isTruthy: <T>(x: T | Falsy) => x is T;

declare class DirectLinkPlugin extends ExtractorPlugin {
    validate(url: string): Promise<boolean>;
    resolve(url: string, options?: {
        member?: GuildMember;
        metadata?: any;
    }): Song<any>;
}

declare const version: string;
/**
 * DisTube class
 * @extends EventEmitter
 */
declare class DisTube extends TypedEmitter<TypedDisTubeEvents> {
    #private;
    readonly handler: DisTubeHandler;
    readonly options: Options;
    readonly client: Client;
    readonly queues: QueueManager;
    readonly voices: DisTubeVoiceManager;
    readonly extractorPlugins: ExtractorPlugin[];
    readonly customPlugins: CustomPlugin[];
    readonly filters: Filters;
    /**
     * @deprecated Use `youtubeCookie: Cookie[]` instead. Guide: {@link https://distube.js.org/#/docs/DisTube/main/general/cookie YouTube Cookies}
     */
    constructor(client: Client, otp: DisTubeOptions & {
        youtubeCookie: string;
    });
    /**
     * Create a new DisTube class.
     * @param {Discord.Client} client Discord.JS client
     * @param {DisTubeOptions} [otp] Custom DisTube options
     * @throws {DisTubeError}
     * @example
     * const Discord = require('discord.js'),
     *     DisTube = require('distube'),
     *     client = new Discord.Client();
     * // Create a new DisTube
     * const distube = new DisTube.default(client, { searchSongs: 10 });
     * // client.DisTube = distube // make it access easily
     * client.login("Your Discord Bot Token")
     */
    constructor(client: Client, otp?: DisTubeOptions);
    static get version(): string;
    /**
     * DisTube version
     * @type {string}
     */
    get version(): string;
    /**
     * Play / add a song or playlist from url. Search and play a song if it is not a valid url.
     *
     * @param {Discord.BaseGuildVoiceChannel} voiceChannel The channel will be joined if the bot isn't in any channels,
     * the bot will be moved to this channel if {@link DisTubeOptions}.joinNewVoiceChannel is `true`
     * @param {string|Song|SearchResult|Playlist} song URL | Search string |
     * {@link Song} | {@link SearchResult} | {@link Playlist}
     * @param {PlayOptions} [options] Optional options
     * @throws {DisTubeError}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "play")
     *         distube.play(message.member.voice.channel, args.join(" "), {
     *             member: message.member,
     *             textChannel: message.channel,
     *             message
     *         });
     * });
     * @returns {Promise<void>}
     */
    play(voiceChannel: VoiceBasedChannel, song: string | Song | SearchResult | Playlist, options?: PlayOptions): Promise<void>;
    /**
     * Create a custom playlist
     * @returns {Promise<Playlist>}
     * @param {Array<string|Song|SearchResult>} songs Array of url, Song or SearchResult
     * @param {CustomPlaylistOptions} [options] Optional options
     * @example
     * const songs = ["https://www.youtube.com/watch?v=xxx", "https://www.youtube.com/watch?v=yyy"];
     * const playlist = await distube.createCustomPlaylist(songs, {
     *     member: message.member,
     *     properties: { name: "My playlist name", source: "custom" },
     *     parallel: true
     * });
     * distube.play(voiceChannel, playlist, { ... });
     */
    createCustomPlaylist(songs: (string | Song | SearchResult)[], options?: CustomPlaylistOptions): Promise<Playlist>;
    search(string: string, options?: {
        type?: SearchResultType.VIDEO;
        limit?: number;
        safeSearch?: boolean;
        retried?: boolean;
    }): Promise<Array<SearchResultVideo>>;
    search(string: string, options: {
        type: SearchResultType.PLAYLIST;
        limit?: number;
        safeSearch?: boolean;
        retried?: boolean;
    }): Promise<Array<SearchResultPlaylist>>;
    search(string: string, options?: {
        type?: SearchResultType;
        limit?: number;
        safeSearch?: boolean;
        retried?: boolean;
    }): Promise<Array<SearchResult>>;
    /**
     * Get the guild queue
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Queue?}
     * @throws {Error}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "queue") {
     *         const queue = distube.getQueue(message);
     *         message.channel.send('Current queue:\n' + queue.songs.map((song, id) =>
     *             `**${id+1}**. [${song.name}](${song.url}) - \`${song.formattedDuration}\``
     *         ).join("\n"));
     *     }
     * });
     */
    getQueue(guild: GuildIdResolvable): Queue | undefined;
    /**
     * Pause the guild stream
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Queue} The guild queue
     * @throws {Error}
     */
    pause(guild: GuildIdResolvable): Queue;
    /**
     * Resume the guild stream
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Queue} The guild queue
     * @throws {Error}
     */
    resume(guild: GuildIdResolvable): Queue;
    /**
     * Stop the guild stream
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Promise<void>}
     * @throws {Error}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "stop") {
     *         distube.stop(message);
     *         message.channel.send("Stopped the queue!");
     *     }
     * });
     */
    stop(guild: GuildIdResolvable): Promise<void>;
    /**
     * Set the guild stream's volume
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @param {number} percent The percentage of volume you want to set
     * @returns {Queue} The guild queue
     * @throws {Error}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "volume")
     *         distube.setVolume(message, Number(args[0]));
     * });
     */
    setVolume(guild: GuildIdResolvable, percent: number): Queue;
    /**
     * Skip the playing song if there is a next song in the queue.
     * <info>If {@link Queue#autoplay} is `true` and there is no up next song,
     * DisTube will add and play a related song.</info>
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Promise<Song>} The new Song will be played
     * @throws {Error}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "skip")
     *         distube.skip(message);
     * });
     */
    skip(guild: GuildIdResolvable): Promise<Song>;
    /**
     * Play the previous song
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Promise<Song>} The new Song will be played
     * @throws {Error}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "previous")
     *         distube.previous(message);
     * });
     */
    previous(guild: GuildIdResolvable): Promise<Song>;
    /**
     * Shuffle the guild queue songs
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Promise<Queue>} The guild queue
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "shuffle")
     *         distube.shuffle(message);
     * });
     */
    shuffle(guild: GuildIdResolvable): Promise<Queue>;
    /**
     * Jump to the song number in the queue.
     * The next one is 1, 2,...
     * The previous one is -1, -2,...
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @param {number} num The song number to play
     * @returns {Promise<Song>} The new Song will be played
     * @throws {Error} if `num` is invalid number (0 < num < {@link Queue#songs}.length)
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "jump")
     *         distube.jump(message, parseInt(args[0]))
     *             .catch(err => message.channel.send("Invalid song number."));
     * });
     */
    jump(guild: GuildIdResolvable, num: number): Promise<Song>;
    /**
     * Set the repeat mode of the guild queue.\
     * Toggle mode `(Disabled -> Song -> Queue -> Disabled ->...)` if `mode` is `undefined`
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @param {RepeatMode?} [mode] The repeat modes (toggle if `undefined`)
     * @returns {RepeatMode} The new repeat mode
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "repeat") {
     *         let mode = distube.setRepeatMode(message, parseInt(args[0]));
     *         mode = mode ? mode == 2 ? "Repeat queue" : "Repeat song" : "Off";
     *         message.channel.send("Set repeat mode to `" + mode + "`");
     *     }
     * });
     * @example
     * const { RepeatMode } = require("distube");
     * let mode;
     * switch(distube.setRepeatMode(message, parseInt(args[0]))) {
     *     case RepeatMode.DISABLED:
     *         mode = "Off";
     *         break;
     *     case RepeatMode.SONG:
     *         mode = "Repeat a song";
     *         break;
     *     case RepeatMode.QUEUE:
     *         mode = "Repeat all queue";
     *         break;
     * }
     * message.channel.send("Set repeat mode to `" + mode + "`");
     */
    setRepeatMode(guild: GuildIdResolvable, mode?: number): number;
    /**
     * Toggle autoplay mode
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {boolean} Autoplay mode state
     * @throws {Error}
     * @example
     * client.on('message', (message) => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command == "autoplay") {
     *         const mode = distube.toggleAutoplay(message);
     *         message.channel.send("Set autoplay mode to `" + (mode ? "On" : "Off") + "`");
     *     }
     * });
     */
    toggleAutoplay(guild: GuildIdResolvable): boolean;
    /**
     * Add related song to the queue
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @returns {Promise<Song>} The guild queue
     */
    addRelatedSong(guild: GuildIdResolvable): Promise<Song>;
    /**
     * Set the playing time to another position
     * @param {GuildIdResolvable} guild The type can be resolved to give a {@link Queue}
     * @param {number} time Time in seconds
     * @returns {Queue} Seeked queue
     * @example
     * client.on('message', message => {
     *     if (!message.content.startsWith(config.prefix)) return;
     *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
     *     const command = args.shift();
     *     if (command = 'seek')
     *         distube.seek(message, Number(args[0]));
     * });
     */
    seek(guild: GuildIdResolvable, time: number): Queue;
    /**
     * Emit error event
     * @param {Error} error error
     * @param {Discord.BaseGuildTextChannel} [channel] Text channel where the error is encountered.
     * @private
     */
    emitError(error: Error, channel?: GuildTextBasedChannel): void;
}

export { Awaitable, BaseManager, Chapter, CustomPlaylistOptions, CustomPlugin, DirectLinkPlugin, DisTube, DisTubeBase, DisTubeError, DisTubeEvents, DisTubeHandler, DisTubeOptions, DisTubeStream, DisTubeVoice, DisTubeVoiceEvents, DisTubeVoiceManager, Events, ExtractorPlugin, Filter, FilterManager, FilterResolvable, Filters, GuildIdManager, GuildIdResolvable, Options, OtherSongInfo, PlayHandlerOptions, PlayOptions, Playlist, PlaylistInfo, Plugin, PluginType, Queue, QueueManager, RelatedSong, RepeatMode, ResolveOptions, ResolvePlaylistOptions, SearchResult, SearchResultPlaylist, SearchResultType, SearchResultVideo, Song, StreamType, TaskQueue, TypedDisTubeEvents, checkIntents, checkInvalidKey, chooseBestVideoFormat, DisTube as default, defaultFilters, defaultOptions, formatDuration, isClientInstance, isGuildInstance, isMemberInstance, isMessageInstance, isNsfwChannel, isObject, isRecord, isSnowflake, isSupportedVoiceChannel, isTextChannelInstance, isTruthy, isURL, isVoiceChannelEmpty, objectKeys, parseNumber, resolveGuildId, toSecond, version };
